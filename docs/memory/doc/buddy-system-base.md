# 伙伴系统的基本结构

## 前言

伙伴系统是Linux物理内存管理的核心机制，所有的物理内存的分配回收都依赖于伙伴系统。伙伴系统保障了内存分配的速度和效率，但是思想和实现又足够简单。

## 伙伴系统结构

页帧是伙伴系统内存管理的最小粒度，伙伴系统管理的内存块由`2^order`个连续页帧组成，`order`是内存块的分配阶。

```c
struct zone {
    struct free_area free_area[MAX_ORDER];
}

struct free_area {
    struct list_head	free_list[MIGRATE_TYPES];
    unsigned long		nr_free;
};
```

在内存管理系统中，`zone`结构包含一个关键成员`free_area`，它是一个`struct free_area`类型的数组。这个数组在伙伴系统实现中扮演核心角色。

* 每个`struct free_area`负责管理一组自由链表，这些链表依据内存迁移类型进行划分（迁移类型与内存碎片处理相关）。这些自由链表虽然迁移类型不同，但是管理的内存块尺寸是相同的，内存块的尺寸与该`struct free_area`在数组中的位置（即偏移量）相关联，偏移量直接反映内存块的分配阶。
* 变量`nr_free`记录了`struct free_area`中内存块的数量。
* 基于上述信息，每个`free_area`所管理的页面总数可通过以下公式计算：`total_pages = nr_free * (1 << order)`，其中`(1 << order)`表示分配阶为`order`的内存块的大小。

`MAX_ORDER`表示系统支持的最大分配阶(通常情况下是`11`)，因此伙伴系统支持分配的最大内存块为`1 << (MAX_ORDER - 1) = 1024`个`pages`。在一些特定系统架构下该值也可以被修改。

在伙伴系统中，当分配的内存块尺寸超过了实际需求时，系统会采取如下策略：

* 内存块拆分：系统会将过大的内存块适当地切分为若干个更小的内存块，确保每个切分出来的的内存块恰好满足分配阶要求。
* 链表归位：这些拆分后的较小内存块会被逐一插入到对应大小的`struct free_area`的自由链表中。伙伴系统维护了按内存块大小（包含连续页面的数量）划分的`struct free_area`，每个内存块在对应的`struct free_area`中等待后续的分配请求。

伙伴系统按照如下流程回收一个已分配的内存块：

* 伙伴定位：根据待回收内存块的地址，系统能够精确计算出其对应的伙伴（即大小相同、物理地址相邻的另一个内存块）的地址。
* 空闲状态检测：随后，系统会检查该伙伴内存块是否正处于空闲状态。
* 合并触发：一旦确定伙伴内存块同样为空闲，系统将它们重新整合为一个地址连续的更大的内存块，并将其从原有的自由链表中移除，再将其插入到对应的更大尺寸的自由链表中。

对于合并后的内存块，可以触发进一步的合并回收得到更大的内存块。
